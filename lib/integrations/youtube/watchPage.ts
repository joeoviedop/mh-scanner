const WATCH_URL = "https://www.youtube.com/watch";

type CaptionTrackName = {
  simpleText?: string;
  runs?: Array<{ text?: string }>;
};

type RawCaptionTrack = {
  baseUrl?: string;
  vssId?: string;
  languageCode?: string;
  kind?: string;
  name?: CaptionTrackName;
};

type PlayerResponse = {
  captions?: {
    playerCaptionsTracklistRenderer?: {
      captionTracks?: RawCaptionTrack[];
    };
  };
};

export type WatchCaptionTrack = {
  baseUrl: string;
  vssId?: string;
  languageCode?: string;
  kind?: string;
  name?: string;
  isAutoGenerated: boolean;
};

function extractJsonSegment(html: string, marker: string): string | null {
  const startIndex = html.indexOf(marker);
  if (startIndex === -1) return null;

  let jsonStart = startIndex + marker.length;
  while (jsonStart < html.length && /\s/.test(html[jsonStart])) {
    jsonStart += 1;
  }

  if (jsonStart >= html.length || html[jsonStart] !== "{") {
    return null;
  }

  let depth = 0;
  let index = jsonStart;
  for (; index < html.length; index += 1) {
    const char = html[index];
    if (char === "{") depth += 1;
    else if (char === "}") {
      depth -= 1;
      if (depth === 0) {
        return html.slice(jsonStart, index + 1);
      }
    }
  }

  return null;
}

function parseName(name?: CaptionTrackName): string | undefined {
  if (!name) return undefined;
  if (typeof name === "object" && name !== null) {
    const simple = name.simpleText;
    if (simple && simple.trim()) return simple.trim();
    const runs = name.runs;
    if (Array.isArray(runs)) {
      const combined = runs.map((run) => run.text ?? "").join("").trim();
      return combined || undefined;
    }
  }
  return undefined;
}

export async function fetchWatchPageTracks(videoId: string): Promise<WatchCaptionTrack[]> {
  const url = `${WATCH_URL}?v=${encodeURIComponent(videoId)}&hl=en`;

  const response = await fetch(url, {
    headers: {
      "User-Agent":
        "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 " +
        "(KHTML, like Gecko) Chrome/120.0.0.0 Safari/537.36",
      "Accept-Language": "en-US,en;q=0.9",
      Accept: "text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8",
    },
  });

  if (!response.ok) {
    return [];
  }

  const html = await response.text();
  const marker = "ytInitialPlayerResponse =";
  const jsonSegment = extractJsonSegment(html, marker);
  if (!jsonSegment) {
    return [];
  }

  let data: PlayerResponse;
  try {
    data = JSON.parse(jsonSegment) as PlayerResponse;
  } catch {
    return [];
  }

  const tracks =
    data.captions?.playerCaptionsTracklistRenderer?.captionTracks ?? [];

  return tracks
    .filter((track): track is RawCaptionTrack => Boolean(track?.baseUrl))
    .map((track) => {
      const kind = track.kind ?? "";
      return {
        baseUrl: track.baseUrl!,
        vssId: track.vssId,
        languageCode: track.languageCode,
        kind,
        name: parseName(track.name),
        isAutoGenerated: kind.toLowerCase() === "asr",
      } satisfies WatchCaptionTrack;
    });
}
