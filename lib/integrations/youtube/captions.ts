const CAPTION_ENDPOINT = "https://www.googleapis.com/youtube/v3/captions";
const TIMEDTEXT_ENDPOINT = "https://www.youtube.com/api/timedtext";

type CaptionItem = {
  id: string;
  snippet?: {
    language?: string;
    trackKind?: string;
    isAutoSynced?: boolean;
    name?: { simpleText?: string };
  };
};

export type CaptionSegment = {
  start: number;
  end: number;
  text: string;
};

export type CaptionResult = {
  videoId: string;
  captionId: string;
  language: string | null;
  isAutoGenerated: boolean;
  segments: CaptionSegment[];
  fullText: string;
  wordCount: number;
};

export class YouTubeCaptionsError extends Error {
  constructor(message: string, public readonly status?: number) {
    super(message);
    this.name = "YouTubeCaptionsError";
  }
}

const SPANISH_CODES = ["es", "es-419", "es-ES", "es-MX", "es-AR", "es-CO"];

function normalizeLanguage(code?: string | null): string | null {
  if (!code) return null;
  return code.toLowerCase();
}

function pickCaptionTrack(items: CaptionItem[]): CaptionItem | null {
  if (!items.length) return null;

  const scored = items
    .map((item) => {
      const lang = normalizeLanguage(item.snippet?.language);
      const isAuto = (item.snippet?.trackKind ?? "").toLowerCase() === "asr";
      let score = 0;

      if (lang && SPANISH_CODES.some((code) => lang.startsWith(code))) {
        score += 4;
      }

      if (!isAuto) {
        score += 2;
      }

      if (item.snippet?.name?.simpleText) {
        const name = item.snippet.name.simpleText.toLowerCase();
        if (name.includes("espaÃ±ol") || name.includes("spanish")) {
          score += 1;
        }
      }

      return { item, score, isAuto };
    })
    .sort((a, b) => b.score - a.score);

  return scored[0]?.item ?? null;
}

function parseTimestamp(value: string): number {
  const parts = value.split(":" );
  const [hours, minutes, seconds] =
    parts.length === 3
      ? [Number(parts[0]), Number(parts[1]), Number(parts[2])]
      : parts.length === 2
      ? [0, Number(parts[0]), Number(parts[1])]
      : [0, 0, Number(parts[0])];

  const secs = Number.isNaN(seconds) ? 0 : seconds;
  const mins = Number.isNaN(minutes) ? 0 : minutes;
  const hrs = Number.isNaN(hours) ? 0 : hours;

  return hrs * 3600 + mins * 60 + secs;
}

function parseDuration(start: number, begin?: string, end?: string, dur?: string): number {
  if (end) {
    return parseTimestamp(end) - start;
  }

  if (dur) {
    return parseTimestamp(dur);
  }

  if (begin) {
    return Math.max(parseTimestamp(begin) - start, 0);
  }

  return 0;
}

function decodeEntities(text: string): string {
  return text
    .replace(/&amp;/g, "&")
    .replace(/&lt;/g, "<")
    .replace(/&gt;/g, ">")
    .replace(/&quot;/g, '"')
    .replace(/&apos;/g, "'");
}

function cleanCaptionText(content: string): string {
  return decodeEntities(
    content
      .replace(/<br\s*\/?>(\s*)/gi, " ")
      .replace(/<[^>]+>/g, " ")
      .replace(/\s+/g, " ")
      .trim()
  );
}

function parseTtml(ttml: string): CaptionSegment[] {
  const segments: CaptionSegment[] = [];
  const paragraphRegex = /<p([^>]*)>([\s\S]*?)<\/p>/gi;
  let match: RegExpExecArray | null;

  while ((match = paragraphRegex.exec(ttml)) !== null) {
    const attrs = match[1] ?? "";
    const body = match[2] ?? "";
    const text = cleanCaptionText(body);

    if (!text) continue;

    const begin = attrs.match(/begin="([^"]+)"/i)?.[1];
    if (!begin) continue;

    const start = parseTimestamp(begin);
    const dur = attrs.match(/dur="([^"]+)"/i)?.[1];
    const end = attrs.match(/end="([^"]+)"/i)?.[1];
    const length = parseDuration(start, begin, end, dur);

    segments.push({
      start,
      end: length > 0 ? start + length : start,
      text,
    });
  }

  return segments;
}

async function fetchJson<T>(url: string, headers?: Record<string, string>): Promise<T> {
  const response = await fetch(url, {
    headers,
  });
  if (!response.ok) {
    throw new YouTubeCaptionsError(`YouTube API error (${response.status})`, response.status);
  }
  return response.json() as Promise<T>;
}

async function fetchText(url: string, headers?: Record<string, string>): Promise<string> {
  const response = await fetch(url, {
    headers: {
      Accept: "application/xml",
      ...headers,
    },
  });

  if (!response.ok) {
    throw new YouTubeCaptionsError(`Failed to download captions (${response.status})`, response.status);
  }

  return response.text();
}

type TimedTextAttempt = {
  query: string;
  status: number;
  length: number;
};

async function fetchTimedText(params: {
  videoId: string;
  captionId: string;
  language: string | null;
  isAutoGenerated: boolean;
  trackName?: string;
}): Promise<{ text: string | null; attempts: TimedTextAttempt[] }> {
  const attempts: TimedTextAttempt[] = [];

  const languageVariants = new Set<string | null>();
  if (params.language) {
    const normalized = params.language.replace(/_/g, "-");
    languageVariants.add(normalized);
    languageVariants.add(normalized.toLowerCase());
    const base = normalized.split("-")[0];
    languageVariants.add(base);
  }
  languageVariants.add(null);

  const candidateParams: Record<string, string>[] = [];
  const addCandidate = (candidate: Record<string, string>) => {
    const key = Object.entries(candidate)
      .sort(([a], [b]) => a.localeCompare(b))
      .map(([k, v]) => `${k}=${v}`)
      .join("&");
    if (!candidateParams.some((existing) => {
      const existingKey = Object.entries(existing)
        .sort(([a], [b]) => a.localeCompare(b))
        .map(([k, v]) => `${k}=${v}`)
        .join("&");
      return existingKey === key;
    })) {
      candidateParams.push(candidate);
    }
  };

  for (const lang of languageVariants) {
    const base: Record<string, string> = {
      v: params.videoId,
      fmt: "ttml",
    };

    if (lang) {
      base.lang = lang;
    }

    if (params.captionId) {
      addCandidate({ ...base, id: params.captionId });
    }

    if (params.isAutoGenerated) {
      addCandidate({ ...base, kind: "asr" });
      if (params.captionId) {
        addCandidate({ ...base, id: params.captionId, kind: "asr" });
      }
    } else if (params.trackName) {
      const name = params.trackName.trim();
      addCandidate({ ...base, name });
      if (params.captionId) {
        addCandidate({ ...base, id: params.captionId, name });
      }
    }

    addCandidate(base);
  }

  for (const candidate of candidateParams) {
    const url = new URL(TIMEDTEXT_ENDPOINT);
    Object.entries(candidate).forEach(([key, value]) => {
      url.searchParams.set(key, value);
    });

    const response = await fetch(url.toString(), {
      headers: {
        Accept: "application/xml",
      },
    });

    const text = await response.text();
    attempts.push({
      query: url.searchParams.toString(),
      status: response.status,
      length: text.trim().length,
    });

    if (!response.ok) {
      if (response.status >= 500) {
        throw new YouTubeCaptionsError(
          `Timed text download failed (${response.status})`,
          response.status,
        );
      }
      continue;
    }

    if (text.trim().length > 0) {
      return { text, attempts };
    }
  }

  return { text: null, attempts };
}

export async function fetchCaptions(videoId: string, accessToken: string): Promise<CaptionResult | null> {
  if (!videoId) {
    throw new YouTubeCaptionsError("Missing videoId");
  }

  if (!accessToken) {
    throw new YouTubeCaptionsError("Missing YouTube access token");
  }

  const listUrl = new URL(CAPTION_ENDPOINT);
  listUrl.searchParams.set("part", "snippet");
  listUrl.searchParams.set("videoId", videoId);
  const authHeaders = {
    Authorization: `Bearer ${accessToken}`,
  };

  const data = await fetchJson<{ items?: CaptionItem[] }>(listUrl.toString(), authHeaders);
  const items = data.items ?? [];

  const chosen = pickCaptionTrack(items);
  if (!chosen) {
    return null;
  }

  const captionId = chosen.id;
  const language = normalizeLanguage(chosen.snippet?.language);
  const isAutoGenerated = (chosen.snippet?.trackKind ?? "").toLowerCase() === "asr";

  let raw: string | null = null;

  const timedText = await fetchTimedText({
    videoId,
    captionId,
    language,
    isAutoGenerated,
    trackName: chosen.snippet?.name?.simpleText,
  });

  raw = timedText.text;

  if (!raw) {
    const downloadUrl = new URL(`${CAPTION_ENDPOINT}/${captionId}`);
    downloadUrl.searchParams.set("tfmt", "ttml");

    try {
      raw = await fetchText(downloadUrl.toString(), authHeaders);
    } catch (error) {
      if (error instanceof YouTubeCaptionsError && error.status === 401) {
        const summary = timedText.attempts.map((attempt) => `${attempt.status}:${attempt.query}`).join(" | ");
        throw new YouTubeCaptionsError(
          `Captions require OAuth authorization (attempts: ${summary || "none"})`,
          error.status,
        );
      }
      throw error;
    }
  }
  const segments = parseTtml(raw);

  const fullText = segments.map((segment) => segment.text).join(" ");
  const wordCount = fullText ? fullText.split(/\s+/).filter(Boolean).length : 0;

  return {
    videoId,
    captionId,
    language,
    isAutoGenerated,
    segments,
    fullText,
    wordCount,
  };
}

export function summarizeSegments(segments: CaptionSegment[]): {
  start: number;
  end: number;
  text: string;
}[] {
  return segments.map((segment) => ({
    start: segment.start,
    end: segment.end,
    text: segment.text,
  }));
}
