import { fetchWatchPageTracks, type WatchCaptionTrack } from "./watchPage";

const TIMEDTEXT_ENDPOINT = "https://www.youtube.com/api/timedtext";

export type CaptionSegment = {
  start: number;
  end: number;
  text: string;
};

export type CaptionResult = {
  videoId: string;
  captionId: string;
  language: string | null;
  isAutoGenerated: boolean;
  segments: CaptionSegment[];
  fullText: string;
  wordCount: number;
  source: "watch:ttml" | "watch:srv3" | "watch:vtt" | "timedtext";
};

export class YouTubeCaptionsError extends Error {
  constructor(message: string, public readonly status?: number) {
    super(message);
    this.name = "YouTubeCaptionsError";
  }
}

const SPANISH_CODES = ["es", "es-419", "es-es", "es-mx", "es-ar", "es-co"];

function normalizeLanguage(code?: string | null): string | null {
  if (!code) return null;
  return code.toLowerCase();
}

function scoreTrack(track: WatchCaptionTrack): number {
  const lang = normalizeLanguage(track.languageCode);
  const isAuto = track.isAutoGenerated;
  let score = 0;

  if (lang && SPANISH_CODES.some((code) => lang.startsWith(code))) {
    score += 4;
  }

  if (!isAuto) {
    score += 2;
  }

  const name = track.name?.toLowerCase() ?? "";
  if (name.includes("espa√±ol") || name.includes("spanish")) {
    score += 1;
  }

  return score;
}

function parseTimestamp(value: string): number {
  const parts = value.split(":");
  const [hours, minutes, seconds] =
    parts.length === 3
      ? [Number(parts[0]), Number(parts[1]), Number(parts[2])]
      : parts.length === 2
      ? [0, Number(parts[0]), Number(parts[1])]
      : [0, 0, Number(parts[0])];

  const secs = Number.isNaN(seconds) ? 0 : seconds;
  const mins = Number.isNaN(minutes) ? 0 : minutes;
  const hrs = Number.isNaN(hours) ? 0 : hours;

  return hrs * 3600 + mins * 60 + secs;
}

function parseDuration(start: number, begin?: string, end?: string, dur?: string): number {
  if (end) {
    return parseTimestamp(end) - start;
  }

  if (dur) {
    return parseTimestamp(dur);
  }

  if (begin) {
    return Math.max(parseTimestamp(begin) - start, 0);
  }

  return 0;
}

function decodeEntities(text: string): string {
  return text
    .replace(/&amp;/g, "&")
    .replace(/&lt;/g, "<")
    .replace(/&gt;/g, ">")
    .replace(/&quot;/g, '"')
    .replace(/&apos;/g, "'");
}

function cleanCaptionText(content: string): string {
  return decodeEntities(
    content
      .replace(/<br\s*\/?>(\s*)/gi, " ")
      .replace(/<[^>]+>/g, " ")
      .replace(/\s+/g, " ")
      .trim()
  );
}

function parseTtml(ttml: string): CaptionSegment[] {
  const segments: CaptionSegment[] = [];
  const paragraphRegex = /<p([^>]*)>([\s\S]*?)<\/p>/gi;
  let match: RegExpExecArray | null;

  while ((match = paragraphRegex.exec(ttml)) !== null) {
    const attrs = match[1] ?? "";
    const body = match[2] ?? "";
    const text = cleanCaptionText(body);

    if (!text) continue;

    const begin = attrs.match(/begin="([^"]+)"/i)?.[1];
    if (!begin) continue;

    const start = parseTimestamp(begin);
    const dur = attrs.match(/dur="([^"]+)"/i)?.[1];
    const end = attrs.match(/end="([^"]+)"/i)?.[1];
    const length = parseDuration(start, begin, end, dur);

    segments.push({
      start,
      end: length > 0 ? start + length : start,
      text,
    });
  }

  return segments;
}

function parseSrv3(raw: string): CaptionSegment[] {
  const trimmed = raw.trim().replace(/^\)\]\}'/, "");
  let data: unknown;
  try {
    data = JSON.parse(trimmed);
  } catch {
    return [];
  }

  if (!data || typeof data !== "object") {
    return [];
  }

  const events = (data as { events?: Array<Record<string, unknown>> }).events;
  if (!Array.isArray(events)) {
    return [];
  }

  const segments: CaptionSegment[] = [];

  for (const event of events) {
    if (!event || typeof event !== "object") continue;
    const segs = (event as { segs?: Array<{ utf8?: string }> }).segs;
    if (!Array.isArray(segs)) continue;

    const text = segs
      .map((seg) => seg?.utf8 ?? "")
      .join("")
      .replace(/\n+/g, " ");

    const cleaned = decodeEntities(text).replace(/\s+/g, " ").trim();
    if (!cleaned) continue;

    const startMs = (event as { tStartMs?: number }).tStartMs ?? 0;
    const durMs = (event as { dDurationMs?: number }).dDurationMs ?? 0;

    const start = startMs / 1000;
    const end = durMs > 0 ? start + durMs / 1000 : start;

    segments.push({ start, end, text: cleaned });
  }

  return segments;
}

function parseVtt(vtt: string): CaptionSegment[] {
  const lines = vtt
    .replace(/^WEBVTT[^\n]*\n+/i, "")
    .split(/\r?\n/)
    .map((line) => line.trimEnd());

  const segments: CaptionSegment[] = [];
  let i = 0;

  while (i < lines.length) {
    if (!lines[i]) {
      i += 1;
      continue;
    }

    if (/^\d+$/.test(lines[i])) {
      i += 1;
      continue;
    }

    const timingMatch = lines[i].match(
      /^(\d{2}:\d{2}:\d{2}\.\d{3}|\d{2}:\d{2}\.\d{3})\s+-->\s+(\d{2}:\d{2}:\d{2}\.\d{3}|\d{2}:\d{2}\.\d{3})/,
    );

    if (!timingMatch) {
      i += 1;
      continue;
    }

    const start = parseTimestamp(timingMatch[1].replace(",", "."));
    const end = parseTimestamp(timingMatch[2].replace(",", "."));

    i += 1;
    let text = "";

    while (i < lines.length && lines[i]) {
      text += `${lines[i]} `;
      i += 1;
    }

    const cleaned = text.replace(/\s+/g, " ").trim();
    if (cleaned) {
      segments.push({
        start,
        end,
        text: decodeEntities(cleaned),
      });
    }

    while (i < lines.length && !lines[i]) {
      i += 1;
    }
  }

  return segments;
}

async function attemptUrl(url: URL, type: "ttml" | "srv3" | "vtt"): Promise<CaptionSegment[]> {
  try {
    const response = await fetch(url.toString(), {
      headers: {
        Accept:
          type === "srv3"
            ? "application/json"
            : type === "vtt"
            ? "text/vtt, application/x-subrip"
            : "application/xml",
      },
    });

    if (!response.ok) {
      return [];
    }

    const body = await response.text();
    if (type === "srv3") {
      return parseSrv3(body);
    }
    if (type === "vtt") {
      return parseVtt(body);
    }
    return parseTtml(body);
  } catch {
    return [];
  }
}

async function downloadFromBase(track: WatchCaptionTrack): Promise<{ segments: CaptionSegment[]; source: CaptionResult["source"] | null }> {
  const attempts: Array<{ url: URL; type: "ttml" | "srv3" | "vtt" }> = [];

  try {
    attempts.push({ url: new URL(track.baseUrl), type: "ttml" });
  } catch {
    return { segments: [], source: null };
  }

  const baseClone = new URL(track.baseUrl);
  baseClone.searchParams.set("fmt", "ttml");
  attempts.push({ url: baseClone, type: "ttml" });

  const vttUrl = new URL(track.baseUrl);
  vttUrl.searchParams.set("fmt", "vtt");
  attempts.push({ url: vttUrl, type: "vtt" });

  const vttAliasUrl = new URL(track.baseUrl);
  vttAliasUrl.searchParams.set("fmt", "1");
  attempts.push({ url: vttAliasUrl, type: "vtt" });

  const srv3Url = new URL(track.baseUrl);
  srv3Url.searchParams.set("fmt", "srv3");
  attempts.push({ url: srv3Url, type: "srv3" });

  const srv3NumericUrl = new URL(track.baseUrl);
  srv3NumericUrl.searchParams.set("fmt", "3");
  attempts.push({ url: srv3NumericUrl, type: "srv3" });

  for (const attempt of attempts) {
    const segments = await attemptUrl(attempt.url, attempt.type);
    if (segments.length > 0) {
      return {
        segments,
        source:
          attempt.type === "ttml"
            ? "watch:ttml"
            : attempt.type === "srv3"
            ? "watch:srv3"
            : "watch:vtt",
      };
    }
  }

  return { segments: [], source: null };
}

type TimedTextAttempt = {
  query: string;
  status: number;
  length: number;
};

async function fetchTimedText(params: {
  videoId: string;
  captionId?: string | null;
  language: string | null;
  isAutoGenerated: boolean;
  trackName?: string;
}): Promise<{ text: string | null; attempts: TimedTextAttempt[] }> {
  const attempts: TimedTextAttempt[] = [];

  const languageVariants = new Set<string | null>();
  if (params.language) {
    const normalized = params.language.replace(/_/g, "-");
    languageVariants.add(normalized);
    languageVariants.add(normalized.toLowerCase());
    const base = normalized.split("-")[0];
    languageVariants.add(base);
  }
  languageVariants.add(null);

  const candidateParams: Record<string, string>[] = [];
  const addCandidate = (candidate: Record<string, string>) => {
    const key = Object.entries(candidate)
      .sort(([a], [b]) => a.localeCompare(b))
      .map(([k, v]) => `${k}=${v}`)
      .join("&");
    if (!candidateParams.some((existing) => {
      const existingKey = Object.entries(existing)
        .sort(([a], [b]) => a.localeCompare(b))
        .map(([k, v]) => `${k}=${v}`)
        .join("&");
      return existingKey === key;
    })) {
      candidateParams.push(candidate);
    }
  };

  for (const lang of languageVariants) {
    const base: Record<string, string> = {
      v: params.videoId,
      fmt: "ttml",
    };

    if (lang) {
      base.lang = lang;
    }

    if (params.captionId) {
      addCandidate({ ...base, id: params.captionId });
    }

    if (params.isAutoGenerated) {
      addCandidate({ ...base, kind: "asr" });
      if (params.captionId) {
        addCandidate({ ...base, id: params.captionId, kind: "asr" });
      }
    } else if (params.trackName) {
      const name = params.trackName.trim();
      if (name) {
        addCandidate({ ...base, name });
        if (params.captionId) {
          addCandidate({ ...base, id: params.captionId, name });
        }
      }
    }

    addCandidate(base);
  }

  for (const candidate of candidateParams) {
    const url = new URL(TIMEDTEXT_ENDPOINT);
    Object.entries(candidate).forEach(([key, value]) => {
      url.searchParams.set(key, value);
    });

    const response = await fetch(url.toString(), {
      headers: {
        Accept: "application/xml",
      },
    });

    const text = await response.text();
    attempts.push({
      query: url.searchParams.toString(),
      status: response.status,
      length: text.trim().length,
    });

    if (!response.ok) {
      if (response.status >= 500) {
        throw new YouTubeCaptionsError(
          `Timed text download failed (${response.status})`,
          response.status,
        );
      }
      continue;
    }

    if (text.trim().length > 0) {
      return { text, attempts };
    }
  }

  return { text: null, attempts };
}

function buildResult(
  videoId: string,
  track: WatchCaptionTrack,
  segments: CaptionSegment[],
  source: CaptionResult["source"],
): CaptionResult {
  const language = normalizeLanguage(track.languageCode ?? null);
  const fullText = segments.map((segment) => segment.text).join(" ");
  const wordCount = fullText ? fullText.split(/\s+/).filter(Boolean).length : 0;

  const captionId = track.vssId || track.languageCode || track.baseUrl;

  return {
    videoId,
    captionId,
    language,
    isAutoGenerated: track.isAutoGenerated,
    segments,
    fullText,
    wordCount,
    source,
  };
}

export async function fetchCaptions(videoId: string): Promise<CaptionResult | null> {
  if (!videoId) {
    throw new YouTubeCaptionsError("Missing videoId");
  }

  const watchTracks = await fetchWatchPageTracks(videoId);
  const rankedTracks = watchTracks
    .map((track) => ({ track, score: scoreTrack(track) }))
    .sort((a, b) => b.score - a.score);

  for (const { track } of rankedTracks) {
    const baseResult = await downloadFromBase(track);
    if (baseResult.segments.length > 0 && baseResult.source) {
      return buildResult(videoId, track, baseResult.segments, baseResult.source);
    }

    const timedText = await fetchTimedText({
      videoId,
      captionId: track.vssId,
      language: track.languageCode ?? null,
      isAutoGenerated: track.isAutoGenerated,
      trackName: track.name,
    });

    if (timedText.text) {
      const segments = parseTtml(timedText.text);
      if (segments.length > 0) {
        return buildResult(videoId, track, segments, "timedtext");
      }
    }
  }

  const fallbackLanguages = new Set<string>([
    ...watchTracks
      .map((track) => normalizeLanguage(track.languageCode ?? null))
      .filter((lang): lang is string => Boolean(lang)),
    ...SPANISH_CODES,
    "en",
  ]);

  for (const lang of fallbackLanguages) {
    const timedText = await fetchTimedText({
      videoId,
      language: lang,
      captionId: null,
      isAutoGenerated: true,
    });

    if (timedText.text) {
      const segments = parseTtml(timedText.text);
      if (segments.length > 0) {
        const syntheticTrack: WatchCaptionTrack = {
          baseUrl: `${TIMEDTEXT_ENDPOINT}?v=${encodeURIComponent(videoId)}`,
          languageCode: lang,
          kind: "asr",
          isAutoGenerated: true,
        };

        return buildResult(videoId, syntheticTrack, segments, "timedtext");
      }
    }
  }

  return null;
}

export function summarizeSegments(segments: CaptionSegment[]): {
  start: number;
  end: number;
  text: string;
}[] {
  return segments.map((segment) => ({
    start: segment.start,
    end: segment.end,
    text: segment.text,
  }));
}
