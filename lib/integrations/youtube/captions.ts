const CAPTION_ENDPOINT = "https://www.googleapis.com/youtube/v3/captions";

type CaptionItem = {
  id: string;
  snippet?: {
    language?: string;
    trackKind?: string;
    isAutoSynced?: boolean;
    name?: { simpleText?: string };
  };
};

export type CaptionSegment = {
  start: number;
  end: number;
  text: string;
};

export type CaptionResult = {
  videoId: string;
  captionId: string;
  language: string | null;
  isAutoGenerated: boolean;
  segments: CaptionSegment[];
  fullText: string;
  wordCount: number;
};

export class YouTubeCaptionsError extends Error {
  constructor(message: string, public readonly status?: number) {
    super(message);
    this.name = "YouTubeCaptionsError";
  }
}

const SPANISH_CODES = ["es", "es-419", "es-ES", "es-MX", "es-AR", "es-CO"];

function normalizeLanguage(code?: string | null): string | null {
  if (!code) return null;
  return code.toLowerCase();
}

function pickCaptionTrack(items: CaptionItem[]): CaptionItem | null {
  if (!items.length) return null;

  const scored = items
    .map((item) => {
      const lang = normalizeLanguage(item.snippet?.language);
      const isAuto = (item.snippet?.trackKind ?? "").toLowerCase() === "asr";
      let score = 0;

      if (lang && SPANISH_CODES.some((code) => lang.startsWith(code))) {
        score += 4;
      }

      if (!isAuto) {
        score += 2;
      }

      if (item.snippet?.name?.simpleText) {
        const name = item.snippet.name.simpleText.toLowerCase();
        if (name.includes("espaÃ±ol") || name.includes("spanish")) {
          score += 1;
        }
      }

      return { item, score, isAuto };
    })
    .sort((a, b) => b.score - a.score);

  return scored[0]?.item ?? null;
}

function parseTimestamp(value: string): number {
  const parts = value.split(":" );
  const [hours, minutes, seconds] =
    parts.length === 3
      ? [Number(parts[0]), Number(parts[1]), Number(parts[2])]
      : parts.length === 2
      ? [0, Number(parts[0]), Number(parts[1])]
      : [0, 0, Number(parts[0])];

  const secs = Number.isNaN(seconds) ? 0 : seconds;
  const mins = Number.isNaN(minutes) ? 0 : minutes;
  const hrs = Number.isNaN(hours) ? 0 : hours;

  return hrs * 3600 + mins * 60 + secs;
}

function parseDuration(start: number, begin?: string, end?: string, dur?: string): number {
  if (end) {
    return parseTimestamp(end) - start;
  }

  if (dur) {
    return parseTimestamp(dur);
  }

  if (begin) {
    return Math.max(parseTimestamp(begin) - start, 0);
  }

  return 0;
}

function decodeEntities(text: string): string {
  return text
    .replace(/&amp;/g, "&")
    .replace(/&lt;/g, "<")
    .replace(/&gt;/g, ">")
    .replace(/&quot;/g, '"')
    .replace(/&apos;/g, "'");
}

function cleanCaptionText(content: string): string {
  return decodeEntities(
    content
      .replace(/<br\s*\/?>(\s*)/gi, " ")
      .replace(/<[^>]+>/g, " ")
      .replace(/\s+/g, " ")
      .trim()
  );
}

function parseTtml(ttml: string): CaptionSegment[] {
  const segments: CaptionSegment[] = [];
  const paragraphRegex = /<p([^>]*)>([\s\S]*?)<\/p>/gi;
  let match: RegExpExecArray | null;

  while ((match = paragraphRegex.exec(ttml)) !== null) {
    const attrs = match[1] ?? "";
    const body = match[2] ?? "";
    const text = cleanCaptionText(body);

    if (!text) continue;

    const begin = attrs.match(/begin="([^"]+)"/i)?.[1];
    if (!begin) continue;

    const start = parseTimestamp(begin);
    const dur = attrs.match(/dur="([^"]+)"/i)?.[1];
    const end = attrs.match(/end="([^"]+)"/i)?.[1];
    const length = parseDuration(start, begin, end, dur);

    segments.push({
      start,
      end: length > 0 ? start + length : start,
      text,
    });
  }

  return segments;
}

async function fetchJson<T>(url: string): Promise<T> {
  const response = await fetch(url);
  if (!response.ok) {
    throw new YouTubeCaptionsError(`YouTube API error (${response.status})`, response.status);
  }
  return response.json() as Promise<T>;
}

async function fetchText(url: string): Promise<string> {
  const response = await fetch(url, {
    headers: {
      Accept: "application/xml",
    },
  });

  if (!response.ok) {
    throw new YouTubeCaptionsError(`Failed to download captions (${response.status})`, response.status);
  }

  return response.text();
}

export async function fetchCaptions(videoId: string, apiKey: string): Promise<CaptionResult | null> {
  if (!videoId) {
    throw new YouTubeCaptionsError("Missing videoId");
  }

  if (!apiKey) {
    throw new YouTubeCaptionsError("Missing YOUTUBE_API_KEY environment variable");
  }

  const listUrl = new URL(CAPTION_ENDPOINT);
  listUrl.searchParams.set("part", "snippet");
  listUrl.searchParams.set("videoId", videoId);
  listUrl.searchParams.set("key", apiKey);

  const data = await fetchJson<{ items?: CaptionItem[] }>(listUrl.toString());
  const items = data.items ?? [];

  const chosen = pickCaptionTrack(items);
  if (!chosen) {
    return null;
  }

  const captionId = chosen.id;
  const language = normalizeLanguage(chosen.snippet?.language);
  const isAutoGenerated = (chosen.snippet?.trackKind ?? "").toLowerCase() === "asr";

  const downloadUrl = new URL(`${CAPTION_ENDPOINT}/${captionId}`);
  downloadUrl.searchParams.set("key", apiKey);
  downloadUrl.searchParams.set("tfmt", "ttml");

  const raw = await fetchText(downloadUrl.toString());
  const segments = parseTtml(raw);

  const fullText = segments.map((segment) => segment.text).join(" ");
  const wordCount = fullText ? fullText.split(/\s+/).filter(Boolean).length : 0;

  return {
    videoId,
    captionId,
    language,
    isAutoGenerated,
    segments,
    fullText,
    wordCount,
  };
}

export function summarizeSegments(segments: CaptionSegment[]): {
  start: number;
  end: number;
  text: string;
}[] {
  return segments.map((segment) => ({
    start: segment.start,
    end: segment.end,
    text: segment.text,
  }));
}
