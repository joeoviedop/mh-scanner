import { v } from "convex/values";

import { mutation, query } from "./_generated/server";
import type { Doc } from "./_generated/dataModel";

export const getByEpisodeId = query({
  args: { episodeId: v.id("episodes") },
  handler: async (ctx, { episodeId }) => {
    return ctx.db
      .query("transcriptions")
      .withIndex("by_episode", (q) => q.eq("episodeId", episodeId))
      .first();
  },
});

export const listKeywordMatches = query({
  args: { episodeId: v.id("episodes") },
  handler: async (ctx, { episodeId }) => {
    const transcription = await ctx.db
      .query("transcriptions")
      .withIndex("by_episode", (q) => q.eq("episodeId", episodeId))
      .first();

    if (!transcription) return [];
    return transcription.keywordMatches;
  },
});

export const upsert = mutation({
  args: {
    episodeId: v.id("episodes"),
    videoId: v.string(),
    fullText: v.string(),
    segments: v.array(
      v.object({
        text: v.string(),
        start: v.number(),
        end: v.number(),
      })
    ),
    language: v.optional(v.string()),
    isAutoGenerated: v.boolean(),
    fetchedAt: v.number(),
    wordCount: v.number(),
    hasTherapyKeywords: v.boolean(),
    keywordMatches: v.array(v.string()),
  },
  handler: async (ctx, args) => {
    const existing = await ctx.db
      .query("transcriptions")
      .withIndex("by_episode", (q) => q.eq("episodeId", args.episodeId))
      .first();

    const payload: Omit<Doc<"transcriptions">, "_id" | "_creationTime"> = {
      episodeId: args.episodeId,
      videoId: args.videoId,
      fullText: args.fullText,
      segments: args.segments,
      language: args.language,
      isAutoGenerated: args.isAutoGenerated,
      fetchedAt: args.fetchedAt,
      wordCount: args.wordCount,
      hasTherapyKeywords: args.hasTherapyKeywords,
      keywordMatches: args.keywordMatches,
    };

    if (existing) {
      await ctx.db.patch(existing._id, payload);
      return existing._id;
    }

    return ctx.db.insert("transcriptions", payload);
  },
});

export const removeForEpisode = mutation({
  args: { episodeId: v.id("episodes") },
  handler: async (ctx, { episodeId }) => {
    const docs = await ctx.db
      .query("transcriptions")
      .withIndex("by_episode", (q) => q.eq("episodeId", episodeId))
      .collect();

    await Promise.all(docs.map(async (doc) => ctx.db.delete(doc._id)));
  },
});

export const getSegments = query({
  args: {
    episodeId: v.id("episodes"),
    limit: v.optional(v.number()),
  },
  handler: async (ctx, { episodeId, limit }) => {
    const transcription = await ctx.db
      .query("transcriptions")
      .withIndex("by_episode", (q) => q.eq("episodeId", episodeId))
      .first();

    if (!transcription) return [];

    const segments = transcription.segments.slice(0, limit ?? transcription.segments.length);

    return segments.map((segment) => ({
      start: segment.start,
      end: segment.end,
      text: segment.text,
    }));
  },
});
