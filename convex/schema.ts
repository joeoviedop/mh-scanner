/**
 * Convex Database Schema
 * 
 * Defines the data models for:
 * - Channels (YouTube channels/playlists)
 * - Episodes (individual YouTube videos)
 * - Transcriptions (video transcripts)
 * - Fragments (detected therapy mentions)
 * - Feedback (user feedback on fragments)
 * - Scan Jobs (background processing jobs)
 */

import { defineSchema, defineTable } from "convex/server";
import { v } from "convex/values";

export default defineSchema({
  // YouTube Channels/Playlists that are being monitored
  channels: defineTable({
    // Basic YouTube info
    youtubeId: v.string(), // Channel ID or Playlist ID
    type: v.union(v.literal("channel"), v.literal("playlist")),
    title: v.string(),
    description: v.string(),
    thumbnailUrl: v.optional(v.string()),
    
    // Channel-specific info (when type === "channel")
    subscriberCount: v.optional(v.string()),
    videoCount: v.optional(v.string()),
    customUrl: v.optional(v.string()),
    
    // Playlist-specific info (when type === "playlist")
    channelId: v.optional(v.string()), // Parent channel if this is a playlist
    channelTitle: v.optional(v.string()),
    itemCount: v.optional(v.number()),
    
    // Scanning configuration
    scanEnabled: v.boolean(),
    lastScanAt: v.optional(v.number()), // Unix timestamp
    scanFrequency: v.union(
      v.literal("daily"),
      v.literal("weekly"),
      v.literal("manual")
    ),
    
    // Metadata
    originalUrl: v.string(), // The original URL provided by user
    displayName: v.optional(v.string()), // For @handles or custom names
    addedAt: v.number(), // Unix timestamp
    addedBy: v.string(), // User identifier
    
    // Processing status
    status: v.union(
      v.literal("active"),
      v.literal("paused"),
      v.literal("error"),
      v.literal("deleted")
    ),
    errorMessage: v.optional(v.string()),
  })
    .index("by_youtube_id", ["youtubeId"])
    .index("by_type", ["type"])
    .index("by_status", ["status"])
    .index("by_scan_enabled", ["scanEnabled"])
    .index("by_last_scan", ["lastScanAt"]),

  // Individual YouTube videos (episodes)
  episodes: defineTable({
    // YouTube video info
    videoId: v.string(), // YouTube video ID (11 chars)
    title: v.string(),
    description: v.string(),
    channelId: v.string(), // YouTube channel ID
    channelTitle: v.string(),
    publishedAt: v.number(), // Unix timestamp
    duration: v.string(), // ISO 8601 duration (PT1H2M3S)
    durationSeconds: v.number(), // Duration in seconds for easy filtering
    thumbnailUrl: v.optional(v.string()),
    
    // YouTube stats
    viewCount: v.optional(v.string()),
    likeCount: v.optional(v.string()),
    commentCount: v.optional(v.string()),
    tags: v.optional(v.array(v.string())),
    
    // Internal tracking
    sourceChannel: v.id("channels"), // Reference to the channel/playlist
    discoveredAt: v.number(), // When we first found this episode
    
    // Processing status
    hasTranscription: v.boolean(),
    transcriptionFetchedAt: v.optional(v.number()),
    transcriptionError: v.optional(v.string()),
    
    hasBeenProcessed: v.boolean(),
    processedAt: v.optional(v.number()),
    processingError: v.optional(v.string()),
    
    // Therapy mention detection results
    hasMentions: v.boolean(),
    mentionCount: v.number(),
    averageConfidence: v.optional(v.number()), // 0-100
    
    // Status
    status: v.union(
      v.literal("discovered"),
      v.literal("transcribing"),
      v.literal("processing"),
      v.literal("completed"),
      v.literal("error"),
      v.literal("skipped")
    ),
  })
    .index("by_video_id", ["videoId"])
    .index("by_channel", ["sourceChannel"])
    .index("by_published_at", ["publishedAt"])
    .index("by_has_mentions", ["hasMentions"])
    .index("by_status", ["status"])
    .index("by_duration", ["durationSeconds"])
    .index("by_channel_and_published", ["sourceChannel", "publishedAt"]),

  // Video transcriptions
  transcriptions: defineTable({
    episodeId: v.id("episodes"), // Reference to episode
    videoId: v.string(), // YouTube video ID for quick lookup
    
    // Transcription data
    fullText: v.string(), // Complete transcript
    segments: v.array(v.object({
      text: v.string(),
      start: v.number(), // Start time in seconds
      end: v.number(), // End time in seconds
      confidence: v.optional(v.number()), // 0-1 confidence from YouTube
    })),
    
    // Metadata
    language: v.optional(v.string()), // Detected language
    isAutoGenerated: v.boolean(), // Whether captions were auto-generated
    fetchedAt: v.number(), // When transcription was fetched
    
    // Processing
    wordCount: v.number(),
    hasTherapyKeywords: v.boolean(), // Quick pre-filter flag
    keywordMatches: v.array(v.string()), // Matched therapy keywords
  })
    .index("by_episode", ["episodeId"])
    .index("by_video_id", ["videoId"])
    .index("by_has_keywords", ["hasTherapyKeywords"]),

  // Detected therapy mention fragments
  fragments: defineTable({
    episodeId: v.id("episodes"), // Reference to episode
    transcriptionId: v.id("transcriptions"), // Reference to transcription
    videoId: v.string(), // YouTube video ID for quick lookup
    
    // Fragment content
    text: v.string(), // The extracted text fragment
    context: v.string(), // Wider context (Â±45 seconds)
    startTime: v.number(), // Start timestamp in seconds
    endTime: v.number(), // End timestamp in seconds
    
    // LLM Classification results
    classification: v.object({
      // Primary categorization
      tema: v.union(
        v.literal("testimonio"),
        v.literal("recomendacion"),
        v.literal("reflexion"),
        v.literal("dato"),
        v.literal("otro")
      ),
      
      // Tone analysis
      tono: v.union(
        v.literal("positivo"),
        v.literal("neutro"),
        v.literal("critico"),
        v.literal("preocupante")
      ),
      
      // Sensitivity flags
      sensibilidad: v.array(v.union(
        v.literal("autolesion"),
        v.literal("suicidio"),
        v.literal("abuso"),
        v.literal("trauma"),
        v.literal("crisis"),
        v.literal("ninguna")
      )),
      
      // Confidence score
      confianza: v.number(), // 0-100
      
      // Additional tags
      tags: v.optional(v.array(v.string())),
      
      // Brief explanation of why this was flagged
      razon: v.optional(v.string()),
    }),
    
    // Metadata
    detectedAt: v.number(), // When this fragment was detected
    detectedBy: v.union(
      v.literal("keyword_filter"),
      v.literal("llm_classifier"),
      v.literal("manual")
    ),
    
    // Quality and feedback
    confidenceScore: v.number(), // 0-100, overall confidence
    reviewStatus: v.union(
      v.literal("pending"),
      v.literal("reviewed"),
      v.literal("approved"),
      v.literal("rejected")
    ),
    
    // User feedback summary
    feedbackCount: v.number(),
    positiveFeedback: v.number(),
    negativeFeedback: v.number(),
    averageRating: v.optional(v.number()), // 1-5 scale
  })
    .index("by_episode", ["episodeId"])
    .index("by_video_id", ["videoId"])
    .index("by_confidence", ["confidenceScore"])
    .index("by_review_status", ["reviewStatus"])
    .index("by_tema", ["classification.tema"])
    .index("by_tono", ["classification.tono"])
    .index("by_detected_at", ["detectedAt"])
    .index("by_episode_and_time", ["episodeId", "startTime"]),

  // User feedback on fragments
  feedback: defineTable({
    fragmentId: v.id("fragments"), // Reference to fragment
    
    // Feedback data
    rating: v.union(
      v.literal("useful"),
      v.literal("not_useful"),
      v.literal("irrelevant")
    ),
    
    // Optional detailed ratings (1-5 scale)
    relevanceScore: v.optional(v.number()), // How relevant to therapy/mental health
    qualityScore: v.optional(v.number()), // Quality of the detection
    
    // Optional comment
    comment: v.optional(v.string()),
    
    // Categories for improvement
    issues: v.optional(v.array(v.union(
      v.literal("false_positive"),
      v.literal("wrong_category"),
      v.literal("poor_context"),
      v.literal("incomplete_text"),
      v.literal("timing_off"),
      v.literal("other")
    ))),
    
    // Metadata
    submittedAt: v.number(),
    submittedBy: v.string(), // User identifier
    
    // For tracking changes over time
    version: v.number(), // Version of the fragment when feedback was given
  })
    .index("by_fragment", ["fragmentId"])
    .index("by_rating", ["rating"])
    .index("by_submitted_at", ["submittedAt"])
    .index("by_submitted_by", ["submittedBy"]),

  // Background processing jobs
  scanJobs: defineTable({
    // Job identification
    type: v.union(
      v.literal("fetch_episodes"),
      v.literal("fetch_transcription"),
      v.literal("process_mentions"),
      v.literal("full_channel_scan")
    ),
    
    // Target reference
    targetType: v.union(
      v.literal("channel"),
      v.literal("episode"),
      v.literal("transcription")
    ),
    targetId: v.string(), // ID of the target (channel ID, episode ID, etc.)
    
    // Job status
    status: v.union(
      v.literal("pending"),
      v.literal("running"),
      v.literal("completed"),
      v.literal("failed"),
      v.literal("cancelled")
    ),
    
    // Progress tracking
    progress: v.number(), // 0-100
    currentStep: v.optional(v.string()),
    totalSteps: v.optional(v.number()),
    
    // Results
    itemsProcessed: v.number(),
    itemsTotal: v.optional(v.number()),
    
    // Error handling
    errorMessage: v.optional(v.string()),
    retryCount: v.number(),
    maxRetries: v.number(),
    
    // Timing
    scheduledAt: v.number(), // When job was scheduled
    startedAt: v.optional(v.number()),
    completedAt: v.optional(v.number()),
    
    // Metadata
    createdBy: v.string(), // User or system that created the job
    priority: v.union(v.literal("low"), v.literal("normal"), v.literal("high")),
    
    // Job-specific data
    parameters: v.optional(v.any()), // Job-specific parameters
    results: v.optional(v.any()), // Job results
  })
    .index("by_status", ["status"])
    .index("by_type", ["type"])
    .index("by_target", ["targetType", "targetId"])
    .index("by_scheduled_at", ["scheduledAt"])
    .index("by_priority", ["priority"])
    .index("by_created_by", ["createdBy"]),

  // Keyword Configuration for LLM detection
  keywordConfig: defineTable({
    // Keyword data
    keyword: v.string(), // The actual keyword or phrase
    category: v.string(), // Category (therapy_core, mental_health, treatment, etc.)
    priority: v.union(v.literal("high"), v.literal("medium"), v.literal("low")),
    description: v.string(), // Optional description of when to use this keyword
    
    // Status
    isActive: v.boolean(), // Whether this keyword is currently being used
    
    // Metadata
    lastModified: v.number(), // When this keyword was last updated
  })
    .index("by_keyword", ["keyword"])
    .index("by_category", ["category"])
    .index("by_active", ["isActive"])
    .index("by_priority", ["priority"])
    .index("by_last_modified", ["lastModified"]),
});