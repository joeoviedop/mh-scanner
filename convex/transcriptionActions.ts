import { v } from "convex/values";

import { action } from "./_generated/server";
import { api } from "./_generated/api";
import type { Doc, Id } from "./_generated/dataModel";
import { fetchCaptions } from "../lib/integrations/youtube/captions";
import { matchTherapyKeywords } from "../lib/constants/therapy-keywords";

type FetchCaptionSummary = {
  language: string | null;
  isAutoGenerated: boolean;
  wordCount: number;
  keywordMatches: string[];
};

type FetchCaptionResult =
  | { status: "skipped"; reason: string }
  | { status: "queued"; jobId: Id<"scanJobs"> }
  | { status: "completed"; jobId: Id<"scanJobs">; summary: FetchCaptionSummary }
  | { status: "failed"; jobId: Id<"scanJobs">; error: string };

export const fetchCaptionsForEpisode = action({
  args: {
    episodeId: v.id("episodes"),
    force: v.optional(v.boolean()),
  },
  handler: async (ctx, { episodeId, force = false }): Promise<FetchCaptionResult> => {
    const episode = (await ctx.runQuery(api.episodes.getById, { id: episodeId })) as
      | (Doc<"episodes"> & { _id: Id<"episodes"> })
      | null;
    if (!episode) {
      throw new Error("Episode not found");
    }

    if (episode.hasTranscription && !force) {
      return {
        status: "skipped",
        reason: "already_transcribed",
      } satisfies FetchCaptionResult;
    }

    const existingJob = (await ctx.runQuery(api.scanJobs.getActiveForTarget, {
      targetType: "episode",
      targetId: episode._id,
    })) as (Doc<"scanJobs"> & { _id: Id<"scanJobs"> }) | null;

    if (existingJob) {
      return {
        status: "queued",
        jobId: existingJob._id,
      } satisfies FetchCaptionResult;
    }

    const jobId = (await ctx.runMutation(api.scanJobs.create, {
      type: "fetch_transcription",
      targetType: "episode",
      targetId: episode._id,
      createdBy: "system",
      parameters: {
        episodeId,
        videoId: episode.videoId,
      },
    })) as Id<"scanJobs">;

    await ctx.runMutation(api.scanJobs.updateStatus, {
      jobId,
      status: "running",
      currentStep: "fetch_captions",
      results: {
        message: "Solicitando transcripción vía Apify",
      },
    });

    await ctx.runMutation(api.episodes.updateProcessingStatus, {
      episodeId,
      status: "transcribing",
      hasTranscription: false,
      transcriptionError: undefined,
    });

    try {
      console.log("[transcriptionActions] Fetching captions for episode:", {
        episodeId,
        videoId: episode.videoId,
        title: episode.title,
      });
      
      const { result, debug } = await fetchCaptions(episode.videoId);

      if (!result || result.segments.length === 0) {
        const apifyInfo = debug.apify;
        const message = apifyInfo.runId
          ? `Apify no devolvió transcripción (runId: ${apifyInfo.runId}, items: ${apifyInfo.itemCount}, raw: ${apifyInfo.rawItemCount ?? 0}). Verifica que el video tenga subtítulos disponibles.`
          : "No se pudo obtener transcripción desde Apify. Verifica la configuración del API token.";

        console.error("[transcriptionActions] Apify returned empty result", {
          episodeId,
          videoId: episode.videoId,
          message,
          apify: apifyInfo,
          debugInfo: {
            hasRunId: !!apifyInfo.runId,
            hasDatasetId: !!apifyInfo.datasetId,
            itemCount: apifyInfo.itemCount,
            rawItemCount: apifyInfo.rawItemCount,
            runStatus: apifyInfo.runStatus,
            rawSampleCount: apifyInfo.rawSample?.length ?? 0,
            rawSamplePreview: apifyInfo.rawSample?.slice(0, 2)
          }
        });

        await ctx.runMutation(api.scanJobs.updateStatus, {
          jobId,
          status: "failed",
          errorMessage: message,
          results: {
            debug: {
              ...debug,
              sample: apifyInfo.rawSample?.slice(0, 3),
            },
          },
        });

        await ctx.runMutation(api.episodes.updateProcessingStatus, {
          episodeId,
          status: "error",
          hasTranscription: false,
          transcriptionError: message,
        });

        return {
          status: "failed",
          jobId,
          error: message,
        } satisfies FetchCaptionResult;
      }

      const keywordMatches = matchTherapyKeywords(result.fullText);

      await ctx.runMutation(api.transcriptions.upsert, {
        episodeId,
        videoId: episode.videoId,
        fullText: result.fullText,
        segments: result.segments,
        language: result.language ?? undefined,
        isAutoGenerated: result.isAutoGenerated,
        fetchedAt: Date.now(),
        wordCount: result.wordCount,
        hasTherapyKeywords: keywordMatches.length > 0,
        keywordMatches,
      });

      await ctx.runMutation(api.episodes.updateProcessingStatus, {
        episodeId,
        status: "processing",
        hasTranscription: true,
        transcriptionFetchedAt: Date.now(),
        transcriptionError: undefined,
      });

      await ctx.runMutation(api.scanJobs.updateStatus, {
        jobId,
        status: "completed",
        progress: 100,
        itemsProcessed: result.segments.length,
        currentStep: "completed",
        results: {
          language: result.language,
          isAutoGenerated: result.isAutoGenerated,
          wordCount: result.wordCount,
          segments: result.segments.length,
          keywordMatches,
          debug,
        },
      });

      return {
        status: "completed",
        jobId,
        summary: {
          language: result.language,
          isAutoGenerated: result.isAutoGenerated,
          wordCount: result.wordCount,
          keywordMatches,
        },
      } satisfies FetchCaptionResult;
    } catch (error) {
      const message =
        error instanceof Error ? error.message : "Failed to fetch captions";
      
      console.error("[transcriptionActions] Error fetching captions:", {
        episodeId,
        videoId: episode.videoId,
        error: message,
        errorType: error?.constructor?.name,
        stack: error instanceof Error ? error.stack : undefined
      });

      await ctx.runMutation(api.scanJobs.updateStatus, {
        jobId,
        status: "failed",
        errorMessage: message,
      });

      await ctx.runMutation(api.episodes.updateProcessingStatus, {
        episodeId,
        status: "error",
        hasTranscription: false,
        transcriptionError: message,
      });

      return {
        status: "failed",
        jobId,
        error: message,
      } satisfies FetchCaptionResult;
    }
  },
});
