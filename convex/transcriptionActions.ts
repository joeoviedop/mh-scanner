import { v } from "convex/values";

import { action } from "./_generated/server";
import { api } from "./_generated/api";
import type { Doc, Id } from "./_generated/dataModel";
import { fetchCaptions } from "../lib/integrations/youtube/captions";
import { matchTherapyKeywords } from "../lib/constants/therapy-keywords";

type FetchCaptionSummary = {
  language: string | null;
  isAutoGenerated: boolean;
  wordCount: number;
  keywordMatches: string[];
};

type FetchCaptionResult =
  | { status: "skipped"; reason: string }
  | { status: "queued"; jobId: Id<"scanJobs"> }
  | { status: "completed"; jobId: Id<"scanJobs">; summary: FetchCaptionSummary }
  | { status: "failed"; jobId: Id<"scanJobs">; error: string };

export const fetchCaptionsForEpisode = action({
  args: {
    episodeId: v.id("episodes"),
    force: v.optional(v.boolean()),
  },
  handler: async (ctx, { episodeId, force = false }): Promise<FetchCaptionResult> => {
    const episode = (await ctx.runQuery(api.episodes.getById, { id: episodeId })) as
      | (Doc<"episodes"> & { _id: Id<"episodes"> })
      | null;
    if (!episode) {
      throw new Error("Episode not found");
    }

    if (episode.hasTranscription && !force) {
      return {
        status: "skipped",
        reason: "already_transcribed",
      } satisfies FetchCaptionResult;
    }

    const existingJob = (await ctx.runQuery(api.scanJobs.getActiveForTarget, {
      targetType: "episode",
      targetId: episode._id,
    })) as (Doc<"scanJobs"> & { _id: Id<"scanJobs"> }) | null;

    if (existingJob) {
      return {
        status: "queued",
        jobId: existingJob._id,
      } satisfies FetchCaptionResult;
    }

    const jobId = (await ctx.runMutation(api.scanJobs.create, {
      type: "fetch_transcription",
      targetType: "episode",
      targetId: episode._id,
      createdBy: "system",
      parameters: {
        episodeId,
        videoId: episode.videoId,
      },
    })) as Id<"scanJobs">;

    await ctx.runMutation(api.scanJobs.updateStatus, {
      jobId,
      status: "running",
      currentStep: "fetch_captions",
      results: {
        message: "Solicitando subtítulos públicos (watch page + timedtext)",
      },
    });

    await ctx.runMutation(api.episodes.updateProcessingStatus, {
      episodeId,
      status: "transcribing",
      hasTranscription: false,
      transcriptionError: undefined,
    });

    try {
      const { result, debug } = await fetchCaptions(episode.videoId);

      if (!result || result.segments.length === 0) {
        const availableTracks = debug.watchTracks.length
          ? debug.watchTracks
              .map((track) => `${track.languageCode ?? "?"}${track.isAutoGenerated ? " (auto)" : ""}`)
              .join(", ")
          : "ninguno";
        const timedTextSummary = debug.timedTextAttempts.length
          ? debug.timedTextAttempts
              .slice(-5)
              .map((attempt) => `${attempt.status}:${attempt.query}`)
              .join(" | ")
          : "sin intentos";

        const message = `Sin subtítulos públicos detectables. Pistas: ${availableTracks}. timedtext: ${timedTextSummary}`;
        await ctx.runMutation(api.scanJobs.updateStatus, {
          jobId,
          status: "failed",
          errorMessage: message,
          results: {
            debug,
          },
        });

        await ctx.runMutation(api.episodes.updateProcessingStatus, {
          episodeId,
          status: "skipped",
          hasTranscription: false,
          transcriptionError: message,
        });

        return {
          status: "failed",
          jobId,
          error: message,
        } satisfies FetchCaptionResult;
      }

      const keywordMatches = matchTherapyKeywords(result.fullText);

      await ctx.runMutation(api.transcriptions.upsert, {
        episodeId,
        videoId: episode.videoId,
        fullText: result.fullText,
        segments: result.segments,
        language: result.language ?? undefined,
        isAutoGenerated: result.isAutoGenerated,
        fetchedAt: Date.now(),
        wordCount: result.wordCount,
        hasTherapyKeywords: keywordMatches.length > 0,
        keywordMatches,
      });

      await ctx.runMutation(api.episodes.updateProcessingStatus, {
        episodeId,
        status: "processing",
        hasTranscription: true,
        transcriptionFetchedAt: Date.now(),
        transcriptionError: undefined,
      });

      await ctx.runMutation(api.scanJobs.updateStatus, {
        jobId,
        status: "completed",
        progress: 100,
        itemsProcessed: result.segments.length,
        currentStep: "completed",
        results: {
          language: result.language,
          isAutoGenerated: result.isAutoGenerated,
          wordCount: result.wordCount,
          segments: result.segments.length,
          keywordMatches,
          debug,
        },
      });

      return {
        status: "completed",
        jobId,
        summary: {
          language: result.language,
          isAutoGenerated: result.isAutoGenerated,
          wordCount: result.wordCount,
          keywordMatches,
        },
      } satisfies FetchCaptionResult;
    } catch (error) {
      const message =
        error instanceof Error ? error.message : "Failed to fetch captions";

      await ctx.runMutation(api.scanJobs.updateStatus, {
        jobId,
        status: "failed",
        errorMessage: message,
      });

      await ctx.runMutation(api.episodes.updateProcessingStatus, {
        episodeId,
        status: "error",
        hasTranscription: false,
        transcriptionError: message,
      });

      return {
        status: "failed",
        jobId,
        error: message,
      } satisfies FetchCaptionResult;
    }
  },
});
