import { v } from "convex/values";

import { action } from "./_generated/server";
import { api } from "./_generated/api";
import type { Doc, Id } from "./_generated/dataModel";
import { fetchCaptions } from "../lib/integrations/youtube/captions";
import { matchTherapyKeywords } from "../lib/constants/therapy-keywords";

type FetchCaptionSummary = {
  language: string | null;
  isAutoGenerated: boolean;
  wordCount: number;
  keywordMatches: string[];
};

type FetchCaptionResult =
  | { status: "skipped"; reason: string }
  | { status: "queued"; jobId: Id<"scanJobs"> }
  | { status: "completed"; jobId: Id<"scanJobs">; summary: FetchCaptionSummary }
  | { status: "failed"; jobId: Id<"scanJobs">; error: string };

export const fetchCaptionsForEpisode = action({
  args: {
    episodeId: v.id("episodes"),
    force: v.optional(v.boolean()),
  },
  handler: async (ctx, { episodeId, force = false }): Promise<FetchCaptionResult> => {
    const youtubeApiKey = process.env.YOUTUBE_API_KEY;
    if (!youtubeApiKey) {
      throw new Error("Missing YOUTUBE_API_KEY environment variable");
    }

    const episode = (await ctx.runQuery(api.episodes.getById, { id: episodeId })) as
      | (Doc<"episodes"> & { _id: Id<"episodes"> })
      | null;
    if (!episode) {
      throw new Error("Episode not found");
    }

    if (episode.hasTranscription && !force) {
      return {
        status: "skipped",
        reason: "already_transcribed",
      } satisfies FetchCaptionResult;
    }

    const existingJob = (await ctx.runQuery(api.scanJobs.getActiveForTarget, {
      targetType: "episode",
      targetId: episode._id,
    })) as (Doc<"scanJobs"> & { _id: Id<"scanJobs"> }) | null;

    if (existingJob) {
      return {
        status: "queued",
        jobId: existingJob._id,
      } satisfies FetchCaptionResult;
    }

    const jobId = (await ctx.runMutation(api.scanJobs.create, {
      type: "fetch_transcription",
      targetType: "episode",
      targetId: episode._id,
      createdBy: "system",
      parameters: {
        episodeId,
        videoId: episode.videoId,
      },
    })) as Id<"scanJobs">;

    await ctx.runMutation(api.scanJobs.updateStatus, {
      jobId,
      status: "running",
      currentStep: "fetch_captions",
    });

    await ctx.runMutation(api.episodes.updateProcessingStatus, {
      episodeId,
      status: "transcribing",
      hasTranscription: false,
      transcriptionError: undefined,
    });

    try {
      const result = await fetchCaptions(episode.videoId, youtubeApiKey);

      if (!result || result.segments.length === 0) {
        const message = "No captions available for this video";
        await ctx.runMutation(api.scanJobs.updateStatus, {
          jobId,
          status: "failed",
          errorMessage: message,
        });

        await ctx.runMutation(api.episodes.updateProcessingStatus, {
          episodeId,
          status: "skipped",
          hasTranscription: false,
          transcriptionError: message,
        });

        return {
          status: "failed",
          jobId,
          error: message,
        } satisfies FetchCaptionResult;
      }

      const keywordMatches = matchTherapyKeywords(result.fullText);

      await ctx.runMutation(api.transcriptions.upsert, {
        episodeId,
        videoId: episode.videoId,
        fullText: result.fullText,
        segments: result.segments,
        language: result.language ?? undefined,
        isAutoGenerated: result.isAutoGenerated,
        fetchedAt: Date.now(),
        wordCount: result.wordCount,
        hasTherapyKeywords: keywordMatches.length > 0,
        keywordMatches,
      });

      await ctx.runMutation(api.episodes.updateProcessingStatus, {
        episodeId,
        status: "processing",
        hasTranscription: true,
        transcriptionFetchedAt: Date.now(),
        transcriptionError: undefined,
      });

      await ctx.runMutation(api.scanJobs.updateStatus, {
        jobId,
        status: "completed",
        progress: 100,
        itemsProcessed: result.segments.length,
        currentStep: "completed",
        results: {
          language: result.language,
          isAutoGenerated: result.isAutoGenerated,
          wordCount: result.wordCount,
          segments: result.segments.length,
          keywordMatches,
        },
      });

      return {
        status: "completed",
        jobId,
        summary: {
          language: result.language,
          isAutoGenerated: result.isAutoGenerated,
          wordCount: result.wordCount,
          keywordMatches,
        },
      } satisfies FetchCaptionResult;
    } catch (error) {
      const message =
        error instanceof Error ? error.message : "Failed to fetch captions";

      await ctx.runMutation(api.scanJobs.updateStatus, {
        jobId,
        status: "failed",
        errorMessage: message,
      });

      await ctx.runMutation(api.episodes.updateProcessingStatus, {
        episodeId,
        status: "error",
        hasTranscription: false,
        transcriptionError: message,
      });

      return {
        status: "failed",
        jobId,
        error: message,
      } satisfies FetchCaptionResult;
    }
  },
});
